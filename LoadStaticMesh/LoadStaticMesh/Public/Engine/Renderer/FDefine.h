#pragma once

#include "stdafx.h"
#include "MathHelper.h"

using namespace DirectX;

enum class E_INDEX_TYPE : UINT8
{
	TYPE_UINT_16 = 0,
	TYPE_UINT_32,
};

enum class E_RESOURCE_TYPE : UINT8
{
	TYPE_UNKNOWN = 0,
	TYPE_INDEX_BUFFER,
	TYPE_VERTEX_BUFFER,
	TYPE_CONSTANT_BUFFER,
	TYPE_TEXTURE,
	TYPE_SHADER,
};

typedef struct FVertexData
{
	XMFLOAT3 Position;
	XMFLOAT3 Normal;
	XMFLOAT3 Tangent;
	XMFLOAT2 Tex0;
	XMFLOAT2 Tex1;
	XMFLOAT4 Color;
}FVertexData;

typedef struct FCameraData {
	XMFLOAT3 Location;
	XMFLOAT3 Target;
	XMFLOAT3 Rotator; // {Pitch, Yaw , Roll}
	float Fov;
	float Aspect;
}FCameraData;

typedef enum class ERHI_DATA_FORMAT
{
	FORMAT_UNKNONWN = 0,
	FORMAT_R32G32B32_FLOAT,
	FORMAT_R32G32_FLOAT,
	FORMAT_R32G32B32A32_FLOAT,
}ERHI_DATA_FORMAT;

typedef enum class ERHI_INPUT_CLASSIFICATION
{
	INPUT_CLASSIFICATION_PER_VERTEX_DATA = 0,
	INPUT_CLASSIFICATION_PER_INSTANCE_DATA = 1
} 	ERHI_INPUT_CLASSIFICATION;

struct FRHIInputElement
{
	std::string SemanticName;
	UINT SemanticIndex;
	ERHI_DATA_FORMAT Format;
	UINT InputSlot;
	UINT AlignedByteOffset;
	ERHI_INPUT_CLASSIFICATION InputSlotClass;
	UINT InstanceDataStepRate;
};

//later will add more param, temp use these for this project
struct FRHIPiplineStateInitializer
{
	std::string KeyName;
	const FRHIInputElement* pInpueElement;
	UINT NumElements;
	BYTE* pVSPointer;
	SIZE_T VsPointerLength;
	BYTE* pPsPointer;
	SIZE_T PsPointerLength;
	UINT NumRenderTargets;
};

const FRHIInputElement StandardInputElementDescs[] =
{
	{ "POSITION", 0, ERHI_DATA_FORMAT::FORMAT_R32G32B32_FLOAT, 0, 0, ERHI_INPUT_CLASSIFICATION::INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, ERHI_DATA_FORMAT::FORMAT_R32G32B32_FLOAT, 0, 12, ERHI_INPUT_CLASSIFICATION::INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TANGENT", 0, ERHI_DATA_FORMAT::FORMAT_R32G32B32_FLOAT, 0, 24, ERHI_INPUT_CLASSIFICATION::INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TEXCOORD", 0, ERHI_DATA_FORMAT::FORMAT_R32G32_FLOAT, 0, 36, ERHI_INPUT_CLASSIFICATION::INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "TEXCOORD", 1, ERHI_DATA_FORMAT::FORMAT_R32G32_FLOAT, 0, 44, ERHI_INPUT_CLASSIFICATION::INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	{ "COLOR", 0, ERHI_DATA_FORMAT::FORMAT_R32G32B32A32_FLOAT, 0, 52, ERHI_INPUT_CLASSIFICATION::INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
};

const UINT StandardInputStride = 68;

struct ObjectConstants
{
public: 
	ObjectConstants(){};
	ObjectConstants(XMFLOAT4X4 InWVP)
	:WorldViewProj(InWVP)
	{}

	XMFLOAT4X4 WorldViewProj = MathHelper::Identity4x4();

};

const UINT RENDER_TARGET_COUNT = 3;
const UINT FRAME_COUNT = 3;
const UINT COMMAND_LIST_NUM = 3;